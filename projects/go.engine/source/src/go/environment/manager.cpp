/*
    Go GPL Source Code
    Copyright (C) 2012 Gokhan Ozdogan. 

    This file is part of the Go GPL Source Code ("Go Source Code").  

    Go Source Code is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Go Source Code is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Go Source Code.  If not, see <http://www.gnu.org/licenses/>.

    In addition, the Go Source Code is also subject to certain additional terms.
    You should have received a copy of these additional terms immediately
    following the terms and conditions of the GNU General Public License which
    accompanied the Go Source Code.  If not, please request a copy in writing
    from mailto:goekhan.oezdogan@hotmail.de.
 */


#include "go/stdafx.h"


#include "go/environment/manager.h"


#include "go/environment/variable.h"
#include "go/filesystem/file.h"
#include "go/core/path_utility.h"
#include "go/core/string_utility.h"
#include "go/core/log.h"


go::environment_manager *go::the_environment = nullptr;


// CFG commands
static const char s_CmdSet[] = "set";
static const char s_CmdExec[] = "exec";
static const char s_CommentChar = ';';


// ============================================================================== //
// Helper functions
// ============================================================================== //

static void file_write_variable(go::text_file &file, const go::variable *variable)
{
    file.write(s_CmdSet, sizeof(s_CmdSet) - 1);
    file.write(" ");
    file.write(variable->name());
    file.write(" ");
    file.write(variable->value());
    file.write("\n", 1);
}


// ============================================================================== //
// go::environment_manager member functions
// ============================================================================== //

go::environment_manager::environment_manager()
    : singleton<environment_manager>(the_environment)
{
}


bool go::environment_manager::add_variable(variable *var)
{
    return m_variableMap.emplace(var->name(), var).second;
}


go::variable *go::environment_manager::find(const std::string &name)
{
    auto it = m_variableMap.find(name);
    return it == m_variableMap.end() ? nullptr : it->second;
}


void go::environment_manager::write_file(const file_path &name) const
{
    GO_LOGFILE_INFO("Writing environment configuration to file '%s\'.\n", name.c_str());

    text_file file(name, file::open_mode::create);
	if(file.is_open())
    {
        file.write("; This file was automatically generated by Go.\n");

        for(auto &v : m_variableMap)
        {
            if((v.second->flags() & variable::nonpersistent) != variable::nonpersistent)
            {
                file_write_variable(file, v.second);
            }
        }

        // User configuration to load
        file.write("exec " GO_VARIABLES_USER_CONFIG_FILE);
    }
}


void go::environment_manager::read_file(const file_path &name)
{
    string_list visitedFiles;
    read_file(name, visitedFiles);
}


void go::environment_manager::read_file(const file_path &name, string_list &visitedFiles)
{
    text_file file(name);
    if(file.is_open())
    {
        GO_LOGFILE_INFO("Reading environment configuration file '%s\'...\n", name.c_str());

        std::string line;
        while(file.read_line(line) == file::io_result::okay)
        {
            execute_command(std::move(line), visitedFiles);
        }
    }
}


auto go::environment_manager::execute_command(std::string line) -> parse_result_t
{
    string_list visitedFiles;
    return execute_command(line, visitedFiles);
}


auto go::environment_manager::execute_command(std::string line, string_list &visitedFiles) -> parse_result_t
{
    // Remove comment
    auto commentPos = line.find(s_CommentChar);
    if(commentPos != std::string::npos)
    {
        line.erase(commentPos, line.length() - commentPos);
    }

    if(line.length() == 0)
    {
        return parse_result_t::ok;
    }

    // set
    std::string token;
    go::string_next_token(token, line, false);
    if(token.compare(s_CmdSet) == 0)
    {
        // <name>
        go::string_next_token(token, line, false);
        if(token.length() == 0)
        {
            return parse_result_t::missing_variable;
        }

        // Lookup variable
        auto variable = go::the_environment->find(token);
        if(!variable)
        {
            return parse_result_t::invalid_variable;
        }

        // <value>
        string_trim(line);
        variable->set_value(line);

        return parse_result_t::ok;
    }
    else if(token.compare(s_CmdExec) == 0)
    {
        // <file>
        go::string_next_token(token, line, true);
        if(token.length() == 0)
        {
            return parse_result_t::ok;
        }

        if(std::find(visitedFiles.begin(), visitedFiles.end(), token) != visitedFiles.end())
        {
            return parse_result_t::ok;
        }

        // Add file to visited list
        visitedFiles.push_back(token);

        read_file(token, visitedFiles);
        
        return parse_result_t::ok;
    }

    return parse_result_t::unknown_command;
}


auto go::environment_manager::variables() const noexcept -> const variable_map &
{
    return m_variableMap;
}
